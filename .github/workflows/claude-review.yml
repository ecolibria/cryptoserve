name: Intelligent PR Review

on:
  pull_request:
    types: [opened, synchronize, reopened]
  issue_comment:
    types: [created]

permissions:
  contents: read
  pull-requests: write
  issues: write
  id-token: write

jobs:
  # Job 1: Semantic code review using claude-code-action
  code-review:
    if: >
      github.event_name == 'pull_request' ||
      (github.event_name == 'issue_comment' &&
       github.event.issue.pull_request &&
       contains(github.event.comment.body, '@claude'))
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2
        with:
          fetch-depth: 0

      - name: Run Claude Code Review
        uses: anthropics/claude-code-action@beta
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
          model: claude-sonnet-4-5-20250929
          trigger_phrase: "@claude"
          timeout_minutes: 10
          custom_instructions: |
            You are reviewing a pull request for CryptoServe, an open-source cryptographic inventory and post-quantum readiness platform. The project is a polyglot monorepo: Python backend + SDK (sdk/python/), Node.js zero-dependency CLI (sdk/javascript/), and GitHub Actions workflows. Apply these domain-specific criteria:

            ## 1. Logic Correctness (Critical — Most Important)
            Trace through code with concrete inputs. Do not just read the code — simulate execution.

            - **Scoring and metrics**: When a function computes a score, ratio, or percentage, verify the math with edge cases:
              - What happens with 0 items? 1 item? All items of the same type?
              - Does the denominator make sense? Can division-by-zero occur?
              - Does the scoring unit match the data being counted? (e.g., counting libraries vs algorithms vs classifications — these are different things)
            - **Filter predicates**: Check that .filter() / list comprehension predicates actually select what the variable name claims. Walk through with a concrete example.
            - **Conditional logic**: Check for tautologies (always true) and contradictions (always false) in boolean expressions. e.g., `x !== 'a' || x === 'b'` is always true when x is anything except 'a'.
            - **Data flow**: Verify that function parameters match what callers actually pass. Check that the function operates on the right level of abstraction (per-library vs per-algorithm vs per-classification).
            - **Off-by-one and boundary errors**: Array indexing, loop bounds, string slicing.

            ## 2. Cryptographic Correctness (Critical)
            - Key material must never be logged, serialized to JSON, or returned in API responses
            - Algorithm identifiers must match IANA/NIST naming (e.g., ML-KEM-768, not kyber768)
            - Nonces/IVs must never be reused — check for deterministic generation patterns
            - Random values must use CSPRNG (Python: secrets module, not random; Node.js: crypto.randomBytes, not Math.random)
            - Key derivation must use appropriate KDFs (HKDF, Argon2, scrypt) with proper salt handling
            - Certificate parsing must validate chain of trust, not just leaf cert
            - Encryption blob format must be byte-identical between Python and Node.js SDKs

            ## 3. Security
            - No hardcoded secrets, API keys, or credentials
            - No eval(), exec(), pickle.loads() (Python) or eval(), Function() (JS) on untrusted input
            - SQL queries must use parameterized statements
            - User input must be validated before use in file paths, shell commands, or queries
            - Authentication/authorization checks must not be bypassable
            - Error messages must not leak internal state or stack traces to clients
            - Node.js: check for prototype pollution, ReDoS in regex, command injection via child_process

            ## 4. Cross-SDK Consistency
            - When the same logic exists in both Python (sdk/python/) and Node.js (sdk/javascript/), verify they produce equivalent results for the same inputs
            - Shared data structures (threat timelines, profiles, algorithm classifications, compliance frameworks) must have identical values
            - Scoring functions, risk assessments, and recommendations should produce the same outputs given the same inputs
            - The encrypted blob format must be interoperable

            ## 5. Test Adequacy
            - New code paths should have corresponding tests
            - Tests must actually exercise the logic being tested — watch for tests that pass empty/trivial inputs that skip the interesting code paths
            - Cryptographic operations need both positive and negative test cases
            - Scoring functions need tests with realistic inputs, not just edge cases
            - Edge cases: empty input, single item, all-same-type, maximum sizes, malformed data

            ## 6. SDK API Stability
            - Public function signatures (Python: cryptoserve_core, Node.js: lib/*.mjs exports) must not change without a deprecation path
            - New required parameters on existing public functions are breaking changes — flag them

            ## 7. Code Quality
            - Functions over 50 lines should be examined for decomposition opportunities
            - Avoid deep nesting (>3 levels) — suggest early returns
            - Error handling should be specific (Python: no bare except; JS: no empty catch)
            - Resource cleanup: Python context managers (with), Node.js try/finally patterns

            ## What to Skip
            - Style/formatting issues (enforced by linters in CI)
            - Import ordering
            - Docstring/JSDoc style
            - Minor naming preferences that don't affect clarity

  # Job 2: Security-focused review
  security-review:
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      findings-count: ${{ steps.security.outputs.findings-count }}
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2
        with:
          fetch-depth: 0

      - name: Run Security Review
        id: security
        uses: anthropics/claude-code-action@beta
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
          model: claude-sonnet-4-5-20250929
          timeout_minutes: 8
          direct_prompt: |
            Perform a security-focused review of this PR. This is a polyglot project (Python + Node.js).

            ## Security Checks
            1. Injection vulnerabilities (SQL, command, path traversal)
            2. Authentication/authorization bypasses
            3. Insecure deserialization or eval usage (Python: pickle; JS: eval, Function, vm)
            4. Hardcoded credentials or secrets
            5. SSRF or open redirect risks
            6. Cryptographic misuse (weak algorithms, nonce reuse, key leakage, Math.random for crypto)
            7. Prototype pollution (JS: object spread from user input, __proto__ access)
            8. ReDoS (regex denial of service from user-controlled input)
            9. Command injection (Python: subprocess with shell=True; JS: child_process.exec with string interpolation)

            ## Logic Bugs That Create Security Issues
            10. Scoring/gating functions that produce incorrect results (e.g., always returning 0 or 100 due to wrong counting unit)
            11. Filter predicates that are tautologies (always true) or contradictions (always false)
            12. Boolean expressions with redundant clauses that mask intent

            For items 10-12, trace through the code with 2-3 concrete inputs to verify correctness.

            ## False Positive Suppressions
            - Policy/gate files (*_gate.py, *_policies.py) reference algorithm names for detection, not usage
            - Test files may intentionally use weak cryptographic material as fixtures
            - crypto_audit.py and scanner.mjs reference algorithms in detection rules, not usage
            - Scanner output files contain algorithm names as scan results

            At the end, output a single line: FINDINGS_COUNT=N where N is the number of security issues found.

  # Job 3: Auto-merge safe PRs
  auto-merge:
    needs: [code-review, security-review]
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - name: Wait for CI checks
        uses: lewagon/wait-on-check-action@ccfb013c15c8afb7bf2b7c028fb74dc5a068cccc  # v1.3.4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          check-regexp: ^(test|lint|frontend|sdk|security).*
          wait-interval: 30
          allowed-conclusions: success

      - name: Evaluate auto-merge eligibility
        id: evaluate
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          PR_AUTHOR: ${{ github.event.pull_request.user.login }}
          PR_CREATED: ${{ github.event.pull_request.created_at }}
          SECURITY_FINDINGS: ${{ needs.security-review.outputs.findings-count }}
        run: |
          set -euo pipefail

          ELIGIBLE=true
          REASONS=""

          # Condition 1: CI checks passed (handled by wait-on-check-action above)

          # Condition 2: Security review findings == 0
          FINDINGS="${SECURITY_FINDINGS:-unknown}"
          if [[ "$FINDINGS" != "0" && "$FINDINGS" != "" ]]; then
            ELIGIBLE=false
            REASONS="${REASONS}\n- Security review found issues (findings: ${FINDINGS})"
          fi

          # Condition 3: PR author is trusted
          TRUSTED_AUTHORS="dependabot[bot] renovate[bot] decimai"
          if ! echo "$TRUSTED_AUTHORS" | grep -qw "$PR_AUTHOR"; then
            ELIGIBLE=false
            REASONS="${REASONS}\n- PR author '${PR_AUTHOR}' is not in the trusted auto-merge list"
          fi

          # Condition 4: PR is small (<=10 files, <=200 lines changed)
          FILES_CHANGED=$(gh pr view "$PR_NUMBER" --json files --jq '.files | length')
          ADDITIONS=$(gh pr view "$PR_NUMBER" --json additions --jq '.additions')
          DELETIONS=$(gh pr view "$PR_NUMBER" --json deletions --jq '.deletions')
          TOTAL_LINES=$((ADDITIONS + DELETIONS))

          if [[ "$FILES_CHANGED" -gt 10 ]]; then
            ELIGIBLE=false
            REASONS="${REASONS}\n- Too many files changed (${FILES_CHANGED} > 10)"
          fi
          if [[ "$TOTAL_LINES" -gt 200 ]]; then
            ELIGIBLE=false
            REASONS="${REASONS}\n- Too many lines changed (${TOTAL_LINES} > 200)"
          fi

          # Condition 5: No changes to protected paths
          PROTECTED_PATHS=".github/workflows/ backend/app/core/crypto/ backend/app/auth/ sdk/python/packages/cryptoserve-core/cryptoserve_core/ .env docker-compose"
          CHANGED_FILES=$(gh pr view "$PR_NUMBER" --json files --jq '.files[].path')
          for path in $PROTECTED_PATHS; do
            if echo "$CHANGED_FILES" | grep -q "^${path}"; then
              ELIGIBLE=false
              REASONS="${REASONS}\n- Changes to protected path: ${path}"
            fi
          done

          # Condition 6: PR is at least 5 minutes old (anti-rush)
          CREATED_EPOCH=$(date -d "$PR_CREATED" +%s 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%SZ" "$PR_CREATED" +%s 2>/dev/null || echo 0)
          NOW_EPOCH=$(date +%s)
          AGE_MINUTES=$(( (NOW_EPOCH - CREATED_EPOCH) / 60 ))

          if [[ "$AGE_MINUTES" -lt 5 ]]; then
            ELIGIBLE=false
            REASONS="${REASONS}\n- PR is too new (${AGE_MINUTES} min < 5 min minimum)"
          fi

          echo "eligible=$ELIGIBLE" >> "$GITHUB_OUTPUT"
          echo "reasons<<EOF" >> "$GITHUB_OUTPUT"
          echo -e "$REASONS" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Auto-merge PR
        if: steps.evaluate.outputs.eligible == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          gh pr review "$PR_NUMBER" --approve --body "Auto-approved: all CI checks passed, security review clean, small PR from trusted author."
          gh pr merge "$PR_NUMBER" --auto --squash

      - name: Post manual review notice
        if: steps.evaluate.outputs.eligible == 'false'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          REASONS: ${{ steps.evaluate.outputs.reasons }}
        run: |
          BODY=$(cat <<'COMMENT'
          **Manual review required.** This PR did not meet auto-merge criteria:

          COMMENT
          )
          BODY="${BODY}${REASONS}"
          gh pr comment "$PR_NUMBER" --body "$BODY"
